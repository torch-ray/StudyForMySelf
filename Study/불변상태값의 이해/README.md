## 불변상태값의 이해

### 함수형 프로그래밍으로 부터 Flux, Redux, MVI 까지

함수형 프로그래밍의 순수 함수와 상태값 관리를 위한 아키텍처에서 강조하는 상태값의 불변성에 대해 궁금증이 생겼다. 여기서 말하는 불변성은 무엇인가? 일반적인 블로그에서는 상태를 변경하지 않는 것이라고 하는데, 그래서 그게 무슨 말인지는 설명하지 않는다.

물론 글을 쓰신 분들이야 무슨 의미인지 알고 쓰셨겠지만, 상태값의 불변성을 "상태를 변경하지 않는 것" 이라고 설명하는 건 다소 불친절한 느낌이 있다. <s>(솔직히 쓰신 분들도 무슨 의미인지 잘 모르고 쓴 것 같기도...)</s>

어찌됐건 상태값의 불변성은 앞으로의 프로그래밍 패러다임이 어떻게 바뀌든 간 중요한 개념일 것 같으니 한 번쯤은 제대로 공부하고 넘어가야하는 주제인 것 같다.

### 전역변수와 접근제어자

순수함수가 어떻게 상태값의 불변성을 유지하는가를 설명하는 것은 결국 다른 기술블로그와 크게 다르지 않을 것 같아서 넘어가고, 실제 업무에서 상태값의 불변성을 지킨다는 것은 무엇인지 조금 더 실용적으로 알아보자.

전역변수를 생성하는 것은 상태값의 불변성에 왜 나쁜 영향을 미치는가?에 대한 간단한 문제다. 어디에서나 접근할 수 있는 값은 어디에서나 변경가능성이 있기 때문이다. 이 때문에 우리는 굳이 객체 안에 변수를 선언하고 값을 할당하는 방식으로 프로그래밍을 하고 있다.

또한, 왜 접근제어자를 사용하는가? 이 역시도 무분별한 상태값 변경을 막기 위해서다. 결국 상태값 불변성의 핵심은 '무분별한 상태값 변경의 차단'이라고 볼 수 있다. 전역변수를 사용하지 않는 것, 접근제어자를 보수적으로 사용하는 것, 변수대신 상수로 선언하는 것 등 모두 시스템적으로 무분별한 상태값의 변경을 막기위한 시도의 일종이다.

무분별한 상태값 변경이 무서운 점은 무분별한 상태값 변경이 에러가 아니라는 점이다. 에러는 일종의 'Voice Of System'이라고 본다. 시스템의 목소리, 즉 시스템이 개발자에게 지금 잘못된 방향으로 가고 있다는 조언을 주는 것이다. 하지만 무분별한 상태값 변경에 대해서 시스템은 아무말도 하지 않는다. 결국 이러한 문제를 마주하게 되면 어느 부분에서 개발자가 의도한 방향과 다르게 동작하는지 찾는 것에 한 세월이 걸리게 된다... 이 말은 즉, 오늘 퇴근하지 못할 수도 있다는 뜻이다.

### 용이한 상태 변경 추적

```swift
class Person {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}


func convertToLia(_ person: Person, _ name: String) -> Person {
    person.name = name
    return person
}

let zzisun = Person(name: "zzisun")
let lia = convertToLia(zzisun, "Lia")

print(zzisun.name)
print(lia.name)
```
이러한 코드가 있다고 가정했을 때, zzisum.name과 lia.name의 결과값은 "Lia"로 동일하다. 개발자의 의도가 특정 객체를 전달받아서 Lia라는 이름을 가진 새로운 객체를 만들고 싶었다고 가정할 때, 개발자의 의도와 다르게 zzisun이라는 객체의 name도 변하게 되는 것이다.

이러한 상태값 변화는 의도하지 않은 변화라는 문제보다, 의도하지 않은 변화가 어디서 발생했는지를 알기 어렵다는 것에 있다. 코드가 길어지고 프로젝트 크기가 커질 수록 더더욱 문제는 심각해진다. '무분별한 상태값의 변경'은 에러가 아니기 때문이다.

```swift
class Person {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}


func convertToLia(_ name: String) -> Person {
    let newPerson = Person(name: name)
    return newPerson
}

let zzisun = Person(name: "zzisun")
let lia = convertToLia("Lia")

print(zzisun.name)
print(lia.name)
```
이를 해결하기 위한 방법은 간단하다. 새로운 객체를 생성해서 리턴해주면된다. 그럼 우리는 이전값과 현재값이 다르다는 것을 테스트할 수 있고 어떤 부분에서 달라졌는지도 쉽게 알 수 있다. 

물론 이는 쉬운 이해를 위해서 단편적으로 코드를 작성했기 때문에 실무에서 이와 같은 방식으로 코드를 작성하지 않는 다는 점은 알아둬야한다. (단, 이와 같은 원리로 코드를 작성하기는 한다.)

상태를 관리하는 대표적인 라이브러리인 리덕스(Redux)도 이전 상태와 다음 상태를 비교하여 두 객체 같지 않다고 판단될 때 상태가 변경됐다고 판단하고 컴포넌트를 다시 Render하는 방식을 취하고 있다. 

이러한 방식의 특징은 참조에 의한 호출을 사용하는 객체들의 상태 변화를 쉽게 감지한다는 장점이 있다. 다시 말하면 개발자에 의도 아래에서 코드가 컨트롤이 되고, 예상하지 못한 변화를 감지해준다는 것을 의미한다.

### 아 그래서 상태값의 불변성이 뭔데?
1. 무분별한 상태값 변경이 이뤄지지 않을 것
2. 개발자의 의도(컨트롤) 아래에서 상태값 변경이 이뤄질 것  


끝!

### 상태값의 불변성은 만능?

이 글은 상태값의 불변성을 이해하기 위함이고, 상태값의 불변성을 추구하는 것이 항상 옳다라고 말하는 글은 아니다. 이것의 장단점은 본 글에서 다루는 것도 주제와 맞지 않기 때문에 굳이 언급하진 않겠다. 애초에 프로그래밍에 있어서 Silver Bullet이 있을 거라고 생각하는 걸 포기하는 것이 개발자로 살아남는 데 가장 중요한 시작이지 않을까?

[매우 참고한 블로그](https://evan-moon.github.io/2020/01/05/what-is-immutable/)
